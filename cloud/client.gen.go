// Package cloud provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package cloud

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
)

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetClusterDatabases request
	GetClusterDatabases(ctx context.Context, accountId UuidV4, clusterId UuidV4, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateClusterDatabaseWithBody request with any body
	CreateClusterDatabaseWithBody(ctx context.Context, accountId UuidV4, clusterId UuidV4, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateClusterDatabase(ctx context.Context, accountId UuidV4, clusterId UuidV4, body CreateClusterDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteClusterDatabase request
	DeleteClusterDatabase(ctx context.Context, accountId UuidV4, clusterId UuidV4, databaseName ClusterDatabaseName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateClusterDatabaseWithBody request with any body
	UpdateClusterDatabaseWithBody(ctx context.Context, accountId UuidV4, clusterId UuidV4, databaseName ClusterDatabaseName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateClusterDatabase(ctx context.Context, accountId UuidV4, clusterId UuidV4, databaseName ClusterDatabaseName, body UpdateClusterDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateClusterDatabaseTableWithBody request with any body
	CreateClusterDatabaseTableWithBody(ctx context.Context, accountId UuidV4, clusterId UuidV4, databaseName ClusterDatabaseName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateClusterDatabaseTable(ctx context.Context, accountId UuidV4, clusterId UuidV4, databaseName ClusterDatabaseName, body CreateClusterDatabaseTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDatabaseTokens request
	GetDatabaseTokens(ctx context.Context, accountId UuidV4, clusterId UuidV4, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDatabaseTokenWithBody request with any body
	CreateDatabaseTokenWithBody(ctx context.Context, accountId UuidV4, clusterId UuidV4, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDatabaseToken(ctx context.Context, accountId UuidV4, clusterId UuidV4, body CreateDatabaseTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDatabaseToken request
	DeleteDatabaseToken(ctx context.Context, accountId UuidV4, clusterId UuidV4, tokenId UuidV4, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDatabaseToken request
	GetDatabaseToken(ctx context.Context, accountId UuidV4, clusterId UuidV4, tokenId UuidV4, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDatabaseTokenWithBody request with any body
	UpdateDatabaseTokenWithBody(ctx context.Context, accountId UuidV4, clusterId UuidV4, tokenId UuidV4, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDatabaseToken(ctx context.Context, accountId UuidV4, clusterId UuidV4, tokenId UuidV4, body UpdateDatabaseTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetClusterDatabases(ctx context.Context, accountId UuidV4, clusterId UuidV4, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClusterDatabasesRequest(c.Server, accountId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClusterDatabaseWithBody(ctx context.Context, accountId UuidV4, clusterId UuidV4, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClusterDatabaseRequestWithBody(c.Server, accountId, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClusterDatabase(ctx context.Context, accountId UuidV4, clusterId UuidV4, body CreateClusterDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClusterDatabaseRequest(c.Server, accountId, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteClusterDatabase(ctx context.Context, accountId UuidV4, clusterId UuidV4, databaseName ClusterDatabaseName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteClusterDatabaseRequest(c.Server, accountId, clusterId, databaseName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateClusterDatabaseWithBody(ctx context.Context, accountId UuidV4, clusterId UuidV4, databaseName ClusterDatabaseName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClusterDatabaseRequestWithBody(c.Server, accountId, clusterId, databaseName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateClusterDatabase(ctx context.Context, accountId UuidV4, clusterId UuidV4, databaseName ClusterDatabaseName, body UpdateClusterDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClusterDatabaseRequest(c.Server, accountId, clusterId, databaseName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClusterDatabaseTableWithBody(ctx context.Context, accountId UuidV4, clusterId UuidV4, databaseName ClusterDatabaseName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClusterDatabaseTableRequestWithBody(c.Server, accountId, clusterId, databaseName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClusterDatabaseTable(ctx context.Context, accountId UuidV4, clusterId UuidV4, databaseName ClusterDatabaseName, body CreateClusterDatabaseTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClusterDatabaseTableRequest(c.Server, accountId, clusterId, databaseName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDatabaseTokens(ctx context.Context, accountId UuidV4, clusterId UuidV4, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDatabaseTokensRequest(c.Server, accountId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDatabaseTokenWithBody(ctx context.Context, accountId UuidV4, clusterId UuidV4, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDatabaseTokenRequestWithBody(c.Server, accountId, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDatabaseToken(ctx context.Context, accountId UuidV4, clusterId UuidV4, body CreateDatabaseTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDatabaseTokenRequest(c.Server, accountId, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDatabaseToken(ctx context.Context, accountId UuidV4, clusterId UuidV4, tokenId UuidV4, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDatabaseTokenRequest(c.Server, accountId, clusterId, tokenId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDatabaseToken(ctx context.Context, accountId UuidV4, clusterId UuidV4, tokenId UuidV4, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDatabaseTokenRequest(c.Server, accountId, clusterId, tokenId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDatabaseTokenWithBody(ctx context.Context, accountId UuidV4, clusterId UuidV4, tokenId UuidV4, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDatabaseTokenRequestWithBody(c.Server, accountId, clusterId, tokenId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDatabaseToken(ctx context.Context, accountId UuidV4, clusterId UuidV4, tokenId UuidV4, body UpdateDatabaseTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDatabaseTokenRequest(c.Server, accountId, clusterId, tokenId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetClusterDatabasesRequest generates requests for GetClusterDatabases
func NewGetClusterDatabasesRequest(server string, accountId UuidV4, clusterId UuidV4) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts/%s/clusters/%s/databases", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateClusterDatabaseRequest calls the generic CreateClusterDatabase builder with application/json body
func NewCreateClusterDatabaseRequest(server string, accountId UuidV4, clusterId UuidV4, body CreateClusterDatabaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateClusterDatabaseRequestWithBody(server, accountId, clusterId, "application/json", bodyReader)
}

// NewCreateClusterDatabaseRequestWithBody generates requests for CreateClusterDatabase with any type of body
func NewCreateClusterDatabaseRequestWithBody(server string, accountId UuidV4, clusterId UuidV4, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts/%s/clusters/%s/databases", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteClusterDatabaseRequest generates requests for DeleteClusterDatabase
func NewDeleteClusterDatabaseRequest(server string, accountId UuidV4, clusterId UuidV4, databaseName ClusterDatabaseName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "databaseName", runtime.ParamLocationPath, databaseName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts/%s/clusters/%s/databases/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateClusterDatabaseRequest calls the generic UpdateClusterDatabase builder with application/json body
func NewUpdateClusterDatabaseRequest(server string, accountId UuidV4, clusterId UuidV4, databaseName ClusterDatabaseName, body UpdateClusterDatabaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateClusterDatabaseRequestWithBody(server, accountId, clusterId, databaseName, "application/json", bodyReader)
}

// NewUpdateClusterDatabaseRequestWithBody generates requests for UpdateClusterDatabase with any type of body
func NewUpdateClusterDatabaseRequestWithBody(server string, accountId UuidV4, clusterId UuidV4, databaseName ClusterDatabaseName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "databaseName", runtime.ParamLocationPath, databaseName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts/%s/clusters/%s/databases/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateClusterDatabaseTableRequest calls the generic CreateClusterDatabaseTable builder with application/json body
func NewCreateClusterDatabaseTableRequest(server string, accountId UuidV4, clusterId UuidV4, databaseName ClusterDatabaseName, body CreateClusterDatabaseTableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateClusterDatabaseTableRequestWithBody(server, accountId, clusterId, databaseName, "application/json", bodyReader)
}

// NewCreateClusterDatabaseTableRequestWithBody generates requests for CreateClusterDatabaseTable with any type of body
func NewCreateClusterDatabaseTableRequestWithBody(server string, accountId UuidV4, clusterId UuidV4, databaseName ClusterDatabaseName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "databaseName", runtime.ParamLocationPath, databaseName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts/%s/clusters/%s/databases/%s/tables", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDatabaseTokensRequest generates requests for GetDatabaseTokens
func NewGetDatabaseTokensRequest(server string, accountId UuidV4, clusterId UuidV4) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts/%s/clusters/%s/tokens", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDatabaseTokenRequest calls the generic CreateDatabaseToken builder with application/json body
func NewCreateDatabaseTokenRequest(server string, accountId UuidV4, clusterId UuidV4, body CreateDatabaseTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDatabaseTokenRequestWithBody(server, accountId, clusterId, "application/json", bodyReader)
}

// NewCreateDatabaseTokenRequestWithBody generates requests for CreateDatabaseToken with any type of body
func NewCreateDatabaseTokenRequestWithBody(server string, accountId UuidV4, clusterId UuidV4, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts/%s/clusters/%s/tokens", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDatabaseTokenRequest generates requests for DeleteDatabaseToken
func NewDeleteDatabaseTokenRequest(server string, accountId UuidV4, clusterId UuidV4, tokenId UuidV4) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "tokenId", runtime.ParamLocationPath, tokenId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts/%s/clusters/%s/tokens/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDatabaseTokenRequest generates requests for GetDatabaseToken
func NewGetDatabaseTokenRequest(server string, accountId UuidV4, clusterId UuidV4, tokenId UuidV4) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "tokenId", runtime.ParamLocationPath, tokenId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts/%s/clusters/%s/tokens/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateDatabaseTokenRequest calls the generic UpdateDatabaseToken builder with application/json body
func NewUpdateDatabaseTokenRequest(server string, accountId UuidV4, clusterId UuidV4, tokenId UuidV4, body UpdateDatabaseTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDatabaseTokenRequestWithBody(server, accountId, clusterId, tokenId, "application/json", bodyReader)
}

// NewUpdateDatabaseTokenRequestWithBody generates requests for UpdateDatabaseToken with any type of body
func NewUpdateDatabaseTokenRequestWithBody(server string, accountId UuidV4, clusterId UuidV4, tokenId UuidV4, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "tokenId", runtime.ParamLocationPath, tokenId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts/%s/clusters/%s/tokens/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetClusterDatabasesWithResponse request
	GetClusterDatabasesWithResponse(ctx context.Context, accountId UuidV4, clusterId UuidV4, reqEditors ...RequestEditorFn) (*GetClusterDatabasesResponse, error)

	// CreateClusterDatabaseWithBodyWithResponse request with any body
	CreateClusterDatabaseWithBodyWithResponse(ctx context.Context, accountId UuidV4, clusterId UuidV4, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClusterDatabaseResponse, error)

	CreateClusterDatabaseWithResponse(ctx context.Context, accountId UuidV4, clusterId UuidV4, body CreateClusterDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClusterDatabaseResponse, error)

	// DeleteClusterDatabaseWithResponse request
	DeleteClusterDatabaseWithResponse(ctx context.Context, accountId UuidV4, clusterId UuidV4, databaseName ClusterDatabaseName, reqEditors ...RequestEditorFn) (*DeleteClusterDatabaseResponse, error)

	// UpdateClusterDatabaseWithBodyWithResponse request with any body
	UpdateClusterDatabaseWithBodyWithResponse(ctx context.Context, accountId UuidV4, clusterId UuidV4, databaseName ClusterDatabaseName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClusterDatabaseResponse, error)

	UpdateClusterDatabaseWithResponse(ctx context.Context, accountId UuidV4, clusterId UuidV4, databaseName ClusterDatabaseName, body UpdateClusterDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClusterDatabaseResponse, error)

	// CreateClusterDatabaseTableWithBodyWithResponse request with any body
	CreateClusterDatabaseTableWithBodyWithResponse(ctx context.Context, accountId UuidV4, clusterId UuidV4, databaseName ClusterDatabaseName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClusterDatabaseTableResponse, error)

	CreateClusterDatabaseTableWithResponse(ctx context.Context, accountId UuidV4, clusterId UuidV4, databaseName ClusterDatabaseName, body CreateClusterDatabaseTableJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClusterDatabaseTableResponse, error)

	// GetDatabaseTokensWithResponse request
	GetDatabaseTokensWithResponse(ctx context.Context, accountId UuidV4, clusterId UuidV4, reqEditors ...RequestEditorFn) (*GetDatabaseTokensResponse, error)

	// CreateDatabaseTokenWithBodyWithResponse request with any body
	CreateDatabaseTokenWithBodyWithResponse(ctx context.Context, accountId UuidV4, clusterId UuidV4, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDatabaseTokenResponse, error)

	CreateDatabaseTokenWithResponse(ctx context.Context, accountId UuidV4, clusterId UuidV4, body CreateDatabaseTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDatabaseTokenResponse, error)

	// DeleteDatabaseTokenWithResponse request
	DeleteDatabaseTokenWithResponse(ctx context.Context, accountId UuidV4, clusterId UuidV4, tokenId UuidV4, reqEditors ...RequestEditorFn) (*DeleteDatabaseTokenResponse, error)

	// GetDatabaseTokenWithResponse request
	GetDatabaseTokenWithResponse(ctx context.Context, accountId UuidV4, clusterId UuidV4, tokenId UuidV4, reqEditors ...RequestEditorFn) (*GetDatabaseTokenResponse, error)

	// UpdateDatabaseTokenWithBodyWithResponse request with any body
	UpdateDatabaseTokenWithBodyWithResponse(ctx context.Context, accountId UuidV4, clusterId UuidV4, tokenId UuidV4, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDatabaseTokenResponse, error)

	UpdateDatabaseTokenWithResponse(ctx context.Context, accountId UuidV4, clusterId UuidV4, tokenId UuidV4, body UpdateDatabaseTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDatabaseTokenResponse, error)
}

type GetClusterDatabasesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		AccountId UuidV4 `json:"accountId"`
		ClusterId UuidV4 `json:"clusterId"`

		// MaxColumnsPerTable The maximum number of columns per table for the cluster database
		MaxColumnsPerTable ClusterDatabaseMaxColumnsPerTable `json:"maxColumnsPerTable"`

		// MaxTables The maximum number of tables for the cluster database
		MaxTables ClusterDatabaseMaxTables `json:"maxTables"`

		// Name The name of the cluster database
		Name ClusterDatabaseName `json:"name"`

		// PartitionTemplate A template for [partitioning](/influxdb3/cloud-dedicated/admin/custom-partitions/) a cluster database.
		//
		// Each partition template part is evaluated in sequence.
		// The outputs from each part are concatenated with the
		// `|` delimiter to form the final partition key.
		//
		// For example, using the partition template below:
		//
		// ```json
		// [
		//   {
		//     "type": "time",
		//     "value": "%Y"
		//   },
		//   {
		//     "type": "tag",
		//     "value": "bananas"
		//   },
		//   {
		//     "type": "tag",
		//     "value": "plátanos"
		//   },
		//   {
		//     "type": "bucket",
		//     "value": {
		//       "tagName": "c",
		//       "numberOfBuckets": 10
		//     }
		//   }
		// ]
		// ```
		//
		// The following partition keys are derived:
		//
		//   * `time=2023-01-01, a=bananas, b=plátanos, c=ananas`   -> `2023|bananas|plátanos|5`
		//   * `time=2023-01-01, b=plátanos`                        -> `2023|!|plátanos|!`
		//   * `time=2023-01-01, another=cat, b=plátanos`           -> `2023|!|plátanos|!`
		//   * `time=2023-01-01`                                    -> `2023|!|!|!`
		//   * `time=2023-01-01, a=cat|dog, b=!, c=!`               -> `2023|cat%7Cdog|%21|8`
		//   * `time=2023-01-01, a=%50, c=%50`                      -> `2023|%2550|!|9`
		//   * `time=2023-01-01, a=, c=`                            -> `2023|^|!|0`
		//   * `time=2023-01-01, a=<long string>`                   -> `2023|<long string>#|!|!`
		//   * `time=2023-01-01, c=<long string>`                   -> `2023|!|!|<bucket ID for untruncated long string>`
		//
		// When using the default [partitioning](/influxdb3/cloud-dedicated/admin/custom-partitions/) template (YYYY-MM-DD) there is no
		// encoding necessary, as the derived partition key contains a single part, and
		// no reserved characters. [`TemplatePart::Bucket`] parts by definition will
		// always be within the part length limit and contain no restricted characters
		// so are also not percent-encoded and/or truncated.
		PartitionTemplate *ClusterDatabasePartitionTemplate `json:"partitionTemplate,omitempty"`

		// RetentionPeriod The retention period of the [cluster database](/influxdb3/cloud-dedicated/admin/databases/) in nanoseconds, if applicable
		//
		// If the retention period is not set or is set to 0, the database will have infinite retention
		RetentionPeriod ClusterDatabaseRetentionPeriod `json:"retentionPeriod"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetClusterDatabasesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClusterDatabasesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateClusterDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AccountId UuidV4 `json:"accountId"`
		ClusterId UuidV4 `json:"clusterId"`

		// MaxColumnsPerTable The maximum number of columns per table for the cluster database
		MaxColumnsPerTable ClusterDatabaseMaxColumnsPerTable `json:"maxColumnsPerTable"`

		// MaxTables The maximum number of tables for the cluster database
		MaxTables ClusterDatabaseMaxTables `json:"maxTables"`

		// Name The name of the cluster database
		Name ClusterDatabaseName `json:"name"`

		// PartitionTemplate A template for [partitioning](/influxdb3/cloud-dedicated/admin/custom-partitions/) a cluster database.
		//
		// Each partition template part is evaluated in sequence.
		// The outputs from each part are concatenated with the
		// `|` delimiter to form the final partition key.
		//
		// For example, using the partition template below:
		//
		// ```json
		// [
		//   {
		//     "type": "time",
		//     "value": "%Y"
		//   },
		//   {
		//     "type": "tag",
		//     "value": "bananas"
		//   },
		//   {
		//     "type": "tag",
		//     "value": "plátanos"
		//   },
		//   {
		//     "type": "bucket",
		//     "value": {
		//       "tagName": "c",
		//       "numberOfBuckets": 10
		//     }
		//   }
		// ]
		// ```
		//
		// The following partition keys are derived:
		//
		//   * `time=2023-01-01, a=bananas, b=plátanos, c=ananas`   -> `2023|bananas|plátanos|5`
		//   * `time=2023-01-01, b=plátanos`                        -> `2023|!|plátanos|!`
		//   * `time=2023-01-01, another=cat, b=plátanos`           -> `2023|!|plátanos|!`
		//   * `time=2023-01-01`                                    -> `2023|!|!|!`
		//   * `time=2023-01-01, a=cat|dog, b=!, c=!`               -> `2023|cat%7Cdog|%21|8`
		//   * `time=2023-01-01, a=%50, c=%50`                      -> `2023|%2550|!|9`
		//   * `time=2023-01-01, a=, c=`                            -> `2023|^|!|0`
		//   * `time=2023-01-01, a=<long string>`                   -> `2023|<long string>#|!|!`
		//   * `time=2023-01-01, c=<long string>`                   -> `2023|!|!|<bucket ID for untruncated long string>`
		//
		// When using the default [partitioning](/influxdb3/cloud-dedicated/admin/custom-partitions/) template (YYYY-MM-DD) there is no
		// encoding necessary, as the derived partition key contains a single part, and
		// no reserved characters. [`TemplatePart::Bucket`] parts by definition will
		// always be within the part length limit and contain no restricted characters
		// so are also not percent-encoded and/or truncated.
		PartitionTemplate *ClusterDatabasePartitionTemplate `json:"partitionTemplate,omitempty"`

		// RetentionPeriod The retention period of the [cluster database](/influxdb3/cloud-dedicated/admin/databases/) in nanoseconds, if applicable
		//
		// If the retention period is not set or is set to 0, the database will have infinite retention
		RetentionPeriod ClusterDatabaseRetentionPeriod `json:"retentionPeriod"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON409 *Conflict
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateClusterDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateClusterDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteClusterDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteClusterDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteClusterDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateClusterDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AccountId UuidV4 `json:"accountId"`
		ClusterId UuidV4 `json:"clusterId"`

		// MaxColumnsPerTable The maximum number of columns per table for the cluster database
		MaxColumnsPerTable ClusterDatabaseMaxColumnsPerTable `json:"maxColumnsPerTable"`

		// MaxTables The maximum number of tables for the cluster database
		MaxTables ClusterDatabaseMaxTables `json:"maxTables"`

		// Name The name of the cluster database
		Name ClusterDatabaseName `json:"name"`

		// RetentionPeriod The retention period of the [cluster database](/influxdb3/cloud-dedicated/admin/databases/) in nanoseconds, if applicable
		//
		// If the retention period is not set or is set to 0, the database will have infinite retention
		RetentionPeriod ClusterDatabaseRetentionPeriod `json:"retentionPeriod"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateClusterDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateClusterDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateClusterDatabaseTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AccountId UuidV4 `json:"accountId"`
		ClusterId UuidV4 `json:"clusterId"`

		// DatabaseName The name of the cluster database
		DatabaseName ClusterDatabaseName `json:"databaseName"`

		// Name The name of the [cluster database](/influxdb3/cloud-dedicated/admin/databases/) table
		Name ClusterDatabaseTableName `json:"name"`

		// PartitionTemplate A template for [partitioning](/influxdb3/cloud-dedicated/admin/custom-partitions/) a cluster database.
		//
		// Each partition template part is evaluated in sequence.
		// The outputs from each part are concatenated with the
		// `|` delimiter to form the final partition key.
		//
		// For example, using the partition template below:
		//
		// ```json
		// [
		//   {
		//     "type": "time",
		//     "value": "%Y"
		//   },
		//   {
		//     "type": "tag",
		//     "value": "bananas"
		//   },
		//   {
		//     "type": "tag",
		//     "value": "plátanos"
		//   },
		//   {
		//     "type": "bucket",
		//     "value": {
		//       "tagName": "c",
		//       "numberOfBuckets": 10
		//     }
		//   }
		// ]
		// ```
		//
		// The following partition keys are derived:
		//
		//   * `time=2023-01-01, a=bananas, b=plátanos, c=ananas`   -> `2023|bananas|plátanos|5`
		//   * `time=2023-01-01, b=plátanos`                        -> `2023|!|plátanos|!`
		//   * `time=2023-01-01, another=cat, b=plátanos`           -> `2023|!|plátanos|!`
		//   * `time=2023-01-01`                                    -> `2023|!|!|!`
		//   * `time=2023-01-01, a=cat|dog, b=!, c=!`               -> `2023|cat%7Cdog|%21|8`
		//   * `time=2023-01-01, a=%50, c=%50`                      -> `2023|%2550|!|9`
		//   * `time=2023-01-01, a=, c=`                            -> `2023|^|!|0`
		//   * `time=2023-01-01, a=<long string>`                   -> `2023|<long string>#|!|!`
		//   * `time=2023-01-01, c=<long string>`                   -> `2023|!|!|<bucket ID for untruncated long string>`
		//
		// When using the default [partitioning](/influxdb3/cloud-dedicated/admin/custom-partitions/) template (YYYY-MM-DD) there is no
		// encoding necessary, as the derived partition key contains a single part, and
		// no reserved characters. [`TemplatePart::Bucket`] parts by definition will
		// always be within the part length limit and contain no restricted characters
		// so are also not percent-encoded and/or truncated.
		PartitionTemplate *ClusterDatabasePartitionTemplate `json:"partitionTemplate,omitempty"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON409 *Conflict
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateClusterDatabaseTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateClusterDatabaseTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDatabaseTokensResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		AccountId UuidV4                 `json:"accountId"`
		ClusterId UuidV4                 `json:"clusterId"`
		CreatedAt DatabaseTokenCreatedAt `json:"createdAt"`

		// Description The description of the database token
		Description DatabaseTokenDescription `json:"description"`
		Id          UuidV4                   `json:"id"`

		// Permissions The list of permissions the [database token](/influxdb3/cloud-dedicated/admin/tokens/database/) allows
		Permissions DatabaseTokenPermissions `json:"permissions"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDatabaseTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDatabaseTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDatabaseTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AccessToken The access token that can be used to authenticate query and write requests to the cluster
		//
		// The access token is never stored by InfluxDB and is only returned once when the token is created. If the access token is lost, a new token must be created.
		AccessToken DatabaseTokenAccessToken `json:"accessToken"`
		AccountId   UuidV4                   `json:"accountId"`
		ClusterId   UuidV4                   `json:"clusterId"`
		CreatedAt   DatabaseTokenCreatedAt   `json:"createdAt"`

		// Description The description of the database token
		Description DatabaseTokenDescription `json:"description"`
		Id          UuidV4                   `json:"id"`

		// Permissions The list of permissions the [database token](/influxdb3/cloud-dedicated/admin/tokens/database/) allows
		Permissions DatabaseTokenPermissions `json:"permissions"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON409 *Conflict
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateDatabaseTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDatabaseTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDatabaseTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteDatabaseTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDatabaseTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDatabaseTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AccountId UuidV4                 `json:"accountId"`
		ClusterId UuidV4                 `json:"clusterId"`
		CreatedAt DatabaseTokenCreatedAt `json:"createdAt"`

		// Description The description of the database token
		Description DatabaseTokenDescription `json:"description"`
		Id          UuidV4                   `json:"id"`

		// Permissions The list of permissions the [database token](/influxdb3/cloud-dedicated/admin/tokens/database/) allows
		Permissions DatabaseTokenPermissions `json:"permissions"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDatabaseTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDatabaseTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDatabaseTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AccountId UuidV4                 `json:"accountId"`
		ClusterId UuidV4                 `json:"clusterId"`
		CreatedAt DatabaseTokenCreatedAt `json:"createdAt"`

		// Description The description of the database token
		Description DatabaseTokenDescription `json:"description"`
		Id          UuidV4                   `json:"id"`

		// Permissions The list of permissions the [database token](/influxdb3/cloud-dedicated/admin/tokens/database/) allows
		Permissions DatabaseTokenPermissions `json:"permissions"`
	}
	JSON400 *BadRequest
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON404 *NotFound
	JSON409 *Conflict
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateDatabaseTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDatabaseTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetClusterDatabasesWithResponse request returning *GetClusterDatabasesResponse
func (c *ClientWithResponses) GetClusterDatabasesWithResponse(ctx context.Context, accountId UuidV4, clusterId UuidV4, reqEditors ...RequestEditorFn) (*GetClusterDatabasesResponse, error) {
	rsp, err := c.GetClusterDatabases(ctx, accountId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClusterDatabasesResponse(rsp)
}

// CreateClusterDatabaseWithBodyWithResponse request with arbitrary body returning *CreateClusterDatabaseResponse
func (c *ClientWithResponses) CreateClusterDatabaseWithBodyWithResponse(ctx context.Context, accountId UuidV4, clusterId UuidV4, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClusterDatabaseResponse, error) {
	rsp, err := c.CreateClusterDatabaseWithBody(ctx, accountId, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClusterDatabaseResponse(rsp)
}

func (c *ClientWithResponses) CreateClusterDatabaseWithResponse(ctx context.Context, accountId UuidV4, clusterId UuidV4, body CreateClusterDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClusterDatabaseResponse, error) {
	rsp, err := c.CreateClusterDatabase(ctx, accountId, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClusterDatabaseResponse(rsp)
}

// DeleteClusterDatabaseWithResponse request returning *DeleteClusterDatabaseResponse
func (c *ClientWithResponses) DeleteClusterDatabaseWithResponse(ctx context.Context, accountId UuidV4, clusterId UuidV4, databaseName ClusterDatabaseName, reqEditors ...RequestEditorFn) (*DeleteClusterDatabaseResponse, error) {
	rsp, err := c.DeleteClusterDatabase(ctx, accountId, clusterId, databaseName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteClusterDatabaseResponse(rsp)
}

// UpdateClusterDatabaseWithBodyWithResponse request with arbitrary body returning *UpdateClusterDatabaseResponse
func (c *ClientWithResponses) UpdateClusterDatabaseWithBodyWithResponse(ctx context.Context, accountId UuidV4, clusterId UuidV4, databaseName ClusterDatabaseName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClusterDatabaseResponse, error) {
	rsp, err := c.UpdateClusterDatabaseWithBody(ctx, accountId, clusterId, databaseName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClusterDatabaseResponse(rsp)
}

func (c *ClientWithResponses) UpdateClusterDatabaseWithResponse(ctx context.Context, accountId UuidV4, clusterId UuidV4, databaseName ClusterDatabaseName, body UpdateClusterDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClusterDatabaseResponse, error) {
	rsp, err := c.UpdateClusterDatabase(ctx, accountId, clusterId, databaseName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClusterDatabaseResponse(rsp)
}

// CreateClusterDatabaseTableWithBodyWithResponse request with arbitrary body returning *CreateClusterDatabaseTableResponse
func (c *ClientWithResponses) CreateClusterDatabaseTableWithBodyWithResponse(ctx context.Context, accountId UuidV4, clusterId UuidV4, databaseName ClusterDatabaseName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClusterDatabaseTableResponse, error) {
	rsp, err := c.CreateClusterDatabaseTableWithBody(ctx, accountId, clusterId, databaseName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClusterDatabaseTableResponse(rsp)
}

func (c *ClientWithResponses) CreateClusterDatabaseTableWithResponse(ctx context.Context, accountId UuidV4, clusterId UuidV4, databaseName ClusterDatabaseName, body CreateClusterDatabaseTableJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClusterDatabaseTableResponse, error) {
	rsp, err := c.CreateClusterDatabaseTable(ctx, accountId, clusterId, databaseName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClusterDatabaseTableResponse(rsp)
}

// GetDatabaseTokensWithResponse request returning *GetDatabaseTokensResponse
func (c *ClientWithResponses) GetDatabaseTokensWithResponse(ctx context.Context, accountId UuidV4, clusterId UuidV4, reqEditors ...RequestEditorFn) (*GetDatabaseTokensResponse, error) {
	rsp, err := c.GetDatabaseTokens(ctx, accountId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDatabaseTokensResponse(rsp)
}

// CreateDatabaseTokenWithBodyWithResponse request with arbitrary body returning *CreateDatabaseTokenResponse
func (c *ClientWithResponses) CreateDatabaseTokenWithBodyWithResponse(ctx context.Context, accountId UuidV4, clusterId UuidV4, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDatabaseTokenResponse, error) {
	rsp, err := c.CreateDatabaseTokenWithBody(ctx, accountId, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDatabaseTokenResponse(rsp)
}

func (c *ClientWithResponses) CreateDatabaseTokenWithResponse(ctx context.Context, accountId UuidV4, clusterId UuidV4, body CreateDatabaseTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDatabaseTokenResponse, error) {
	rsp, err := c.CreateDatabaseToken(ctx, accountId, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDatabaseTokenResponse(rsp)
}

// DeleteDatabaseTokenWithResponse request returning *DeleteDatabaseTokenResponse
func (c *ClientWithResponses) DeleteDatabaseTokenWithResponse(ctx context.Context, accountId UuidV4, clusterId UuidV4, tokenId UuidV4, reqEditors ...RequestEditorFn) (*DeleteDatabaseTokenResponse, error) {
	rsp, err := c.DeleteDatabaseToken(ctx, accountId, clusterId, tokenId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDatabaseTokenResponse(rsp)
}

// GetDatabaseTokenWithResponse request returning *GetDatabaseTokenResponse
func (c *ClientWithResponses) GetDatabaseTokenWithResponse(ctx context.Context, accountId UuidV4, clusterId UuidV4, tokenId UuidV4, reqEditors ...RequestEditorFn) (*GetDatabaseTokenResponse, error) {
	rsp, err := c.GetDatabaseToken(ctx, accountId, clusterId, tokenId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDatabaseTokenResponse(rsp)
}

// UpdateDatabaseTokenWithBodyWithResponse request with arbitrary body returning *UpdateDatabaseTokenResponse
func (c *ClientWithResponses) UpdateDatabaseTokenWithBodyWithResponse(ctx context.Context, accountId UuidV4, clusterId UuidV4, tokenId UuidV4, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDatabaseTokenResponse, error) {
	rsp, err := c.UpdateDatabaseTokenWithBody(ctx, accountId, clusterId, tokenId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDatabaseTokenResponse(rsp)
}

func (c *ClientWithResponses) UpdateDatabaseTokenWithResponse(ctx context.Context, accountId UuidV4, clusterId UuidV4, tokenId UuidV4, body UpdateDatabaseTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDatabaseTokenResponse, error) {
	rsp, err := c.UpdateDatabaseToken(ctx, accountId, clusterId, tokenId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDatabaseTokenResponse(rsp)
}

// ParseGetClusterDatabasesResponse parses an HTTP response from a GetClusterDatabasesWithResponse call
func ParseGetClusterDatabasesResponse(rsp *http.Response) (*GetClusterDatabasesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClusterDatabasesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			AccountId UuidV4 `json:"accountId"`
			ClusterId UuidV4 `json:"clusterId"`

			// MaxColumnsPerTable The maximum number of columns per table for the cluster database
			MaxColumnsPerTable ClusterDatabaseMaxColumnsPerTable `json:"maxColumnsPerTable"`

			// MaxTables The maximum number of tables for the cluster database
			MaxTables ClusterDatabaseMaxTables `json:"maxTables"`

			// Name The name of the cluster database
			Name ClusterDatabaseName `json:"name"`

			// PartitionTemplate A template for [partitioning](/influxdb3/cloud-dedicated/admin/custom-partitions/) a cluster database.
			//
			// Each partition template part is evaluated in sequence.
			// The outputs from each part are concatenated with the
			// `|` delimiter to form the final partition key.
			//
			// For example, using the partition template below:
			//
			// ```json
			// [
			//   {
			//     "type": "time",
			//     "value": "%Y"
			//   },
			//   {
			//     "type": "tag",
			//     "value": "bananas"
			//   },
			//   {
			//     "type": "tag",
			//     "value": "plátanos"
			//   },
			//   {
			//     "type": "bucket",
			//     "value": {
			//       "tagName": "c",
			//       "numberOfBuckets": 10
			//     }
			//   }
			// ]
			// ```
			//
			// The following partition keys are derived:
			//
			//   * `time=2023-01-01, a=bananas, b=plátanos, c=ananas`   -> `2023|bananas|plátanos|5`
			//   * `time=2023-01-01, b=plátanos`                        -> `2023|!|plátanos|!`
			//   * `time=2023-01-01, another=cat, b=plátanos`           -> `2023|!|plátanos|!`
			//   * `time=2023-01-01`                                    -> `2023|!|!|!`
			//   * `time=2023-01-01, a=cat|dog, b=!, c=!`               -> `2023|cat%7Cdog|%21|8`
			//   * `time=2023-01-01, a=%50, c=%50`                      -> `2023|%2550|!|9`
			//   * `time=2023-01-01, a=, c=`                            -> `2023|^|!|0`
			//   * `time=2023-01-01, a=<long string>`                   -> `2023|<long string>#|!|!`
			//   * `time=2023-01-01, c=<long string>`                   -> `2023|!|!|<bucket ID for untruncated long string>`
			//
			// When using the default [partitioning](/influxdb3/cloud-dedicated/admin/custom-partitions/) template (YYYY-MM-DD) there is no
			// encoding necessary, as the derived partition key contains a single part, and
			// no reserved characters. [`TemplatePart::Bucket`] parts by definition will
			// always be within the part length limit and contain no restricted characters
			// so are also not percent-encoded and/or truncated.
			PartitionTemplate *ClusterDatabasePartitionTemplate `json:"partitionTemplate,omitempty"`

			// RetentionPeriod The retention period of the [cluster database](/influxdb3/cloud-dedicated/admin/databases/) in nanoseconds, if applicable
			//
			// If the retention period is not set or is set to 0, the database will have infinite retention
			RetentionPeriod ClusterDatabaseRetentionPeriod `json:"retentionPeriod"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateClusterDatabaseResponse parses an HTTP response from a CreateClusterDatabaseWithResponse call
func ParseCreateClusterDatabaseResponse(rsp *http.Response) (*CreateClusterDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateClusterDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AccountId UuidV4 `json:"accountId"`
			ClusterId UuidV4 `json:"clusterId"`

			// MaxColumnsPerTable The maximum number of columns per table for the cluster database
			MaxColumnsPerTable ClusterDatabaseMaxColumnsPerTable `json:"maxColumnsPerTable"`

			// MaxTables The maximum number of tables for the cluster database
			MaxTables ClusterDatabaseMaxTables `json:"maxTables"`

			// Name The name of the cluster database
			Name ClusterDatabaseName `json:"name"`

			// PartitionTemplate A template for [partitioning](/influxdb3/cloud-dedicated/admin/custom-partitions/) a cluster database.
			//
			// Each partition template part is evaluated in sequence.
			// The outputs from each part are concatenated with the
			// `|` delimiter to form the final partition key.
			//
			// For example, using the partition template below:
			//
			// ```json
			// [
			//   {
			//     "type": "time",
			//     "value": "%Y"
			//   },
			//   {
			//     "type": "tag",
			//     "value": "bananas"
			//   },
			//   {
			//     "type": "tag",
			//     "value": "plátanos"
			//   },
			//   {
			//     "type": "bucket",
			//     "value": {
			//       "tagName": "c",
			//       "numberOfBuckets": 10
			//     }
			//   }
			// ]
			// ```
			//
			// The following partition keys are derived:
			//
			//   * `time=2023-01-01, a=bananas, b=plátanos, c=ananas`   -> `2023|bananas|plátanos|5`
			//   * `time=2023-01-01, b=plátanos`                        -> `2023|!|plátanos|!`
			//   * `time=2023-01-01, another=cat, b=plátanos`           -> `2023|!|plátanos|!`
			//   * `time=2023-01-01`                                    -> `2023|!|!|!`
			//   * `time=2023-01-01, a=cat|dog, b=!, c=!`               -> `2023|cat%7Cdog|%21|8`
			//   * `time=2023-01-01, a=%50, c=%50`                      -> `2023|%2550|!|9`
			//   * `time=2023-01-01, a=, c=`                            -> `2023|^|!|0`
			//   * `time=2023-01-01, a=<long string>`                   -> `2023|<long string>#|!|!`
			//   * `time=2023-01-01, c=<long string>`                   -> `2023|!|!|<bucket ID for untruncated long string>`
			//
			// When using the default [partitioning](/influxdb3/cloud-dedicated/admin/custom-partitions/) template (YYYY-MM-DD) there is no
			// encoding necessary, as the derived partition key contains a single part, and
			// no reserved characters. [`TemplatePart::Bucket`] parts by definition will
			// always be within the part length limit and contain no restricted characters
			// so are also not percent-encoded and/or truncated.
			PartitionTemplate *ClusterDatabasePartitionTemplate `json:"partitionTemplate,omitempty"`

			// RetentionPeriod The retention period of the [cluster database](/influxdb3/cloud-dedicated/admin/databases/) in nanoseconds, if applicable
			//
			// If the retention period is not set or is set to 0, the database will have infinite retention
			RetentionPeriod ClusterDatabaseRetentionPeriod `json:"retentionPeriod"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteClusterDatabaseResponse parses an HTTP response from a DeleteClusterDatabaseWithResponse call
func ParseDeleteClusterDatabaseResponse(rsp *http.Response) (*DeleteClusterDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteClusterDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateClusterDatabaseResponse parses an HTTP response from a UpdateClusterDatabaseWithResponse call
func ParseUpdateClusterDatabaseResponse(rsp *http.Response) (*UpdateClusterDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateClusterDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AccountId UuidV4 `json:"accountId"`
			ClusterId UuidV4 `json:"clusterId"`

			// MaxColumnsPerTable The maximum number of columns per table for the cluster database
			MaxColumnsPerTable ClusterDatabaseMaxColumnsPerTable `json:"maxColumnsPerTable"`

			// MaxTables The maximum number of tables for the cluster database
			MaxTables ClusterDatabaseMaxTables `json:"maxTables"`

			// Name The name of the cluster database
			Name ClusterDatabaseName `json:"name"`

			// RetentionPeriod The retention period of the [cluster database](/influxdb3/cloud-dedicated/admin/databases/) in nanoseconds, if applicable
			//
			// If the retention period is not set or is set to 0, the database will have infinite retention
			RetentionPeriod ClusterDatabaseRetentionPeriod `json:"retentionPeriod"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateClusterDatabaseTableResponse parses an HTTP response from a CreateClusterDatabaseTableWithResponse call
func ParseCreateClusterDatabaseTableResponse(rsp *http.Response) (*CreateClusterDatabaseTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateClusterDatabaseTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AccountId UuidV4 `json:"accountId"`
			ClusterId UuidV4 `json:"clusterId"`

			// DatabaseName The name of the cluster database
			DatabaseName ClusterDatabaseName `json:"databaseName"`

			// Name The name of the [cluster database](/influxdb3/cloud-dedicated/admin/databases/) table
			Name ClusterDatabaseTableName `json:"name"`

			// PartitionTemplate A template for [partitioning](/influxdb3/cloud-dedicated/admin/custom-partitions/) a cluster database.
			//
			// Each partition template part is evaluated in sequence.
			// The outputs from each part are concatenated with the
			// `|` delimiter to form the final partition key.
			//
			// For example, using the partition template below:
			//
			// ```json
			// [
			//   {
			//     "type": "time",
			//     "value": "%Y"
			//   },
			//   {
			//     "type": "tag",
			//     "value": "bananas"
			//   },
			//   {
			//     "type": "tag",
			//     "value": "plátanos"
			//   },
			//   {
			//     "type": "bucket",
			//     "value": {
			//       "tagName": "c",
			//       "numberOfBuckets": 10
			//     }
			//   }
			// ]
			// ```
			//
			// The following partition keys are derived:
			//
			//   * `time=2023-01-01, a=bananas, b=plátanos, c=ananas`   -> `2023|bananas|plátanos|5`
			//   * `time=2023-01-01, b=plátanos`                        -> `2023|!|plátanos|!`
			//   * `time=2023-01-01, another=cat, b=plátanos`           -> `2023|!|plátanos|!`
			//   * `time=2023-01-01`                                    -> `2023|!|!|!`
			//   * `time=2023-01-01, a=cat|dog, b=!, c=!`               -> `2023|cat%7Cdog|%21|8`
			//   * `time=2023-01-01, a=%50, c=%50`                      -> `2023|%2550|!|9`
			//   * `time=2023-01-01, a=, c=`                            -> `2023|^|!|0`
			//   * `time=2023-01-01, a=<long string>`                   -> `2023|<long string>#|!|!`
			//   * `time=2023-01-01, c=<long string>`                   -> `2023|!|!|<bucket ID for untruncated long string>`
			//
			// When using the default [partitioning](/influxdb3/cloud-dedicated/admin/custom-partitions/) template (YYYY-MM-DD) there is no
			// encoding necessary, as the derived partition key contains a single part, and
			// no reserved characters. [`TemplatePart::Bucket`] parts by definition will
			// always be within the part length limit and contain no restricted characters
			// so are also not percent-encoded and/or truncated.
			PartitionTemplate *ClusterDatabasePartitionTemplate `json:"partitionTemplate,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDatabaseTokensResponse parses an HTTP response from a GetDatabaseTokensWithResponse call
func ParseGetDatabaseTokensResponse(rsp *http.Response) (*GetDatabaseTokensResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDatabaseTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			AccountId UuidV4                 `json:"accountId"`
			ClusterId UuidV4                 `json:"clusterId"`
			CreatedAt DatabaseTokenCreatedAt `json:"createdAt"`

			// Description The description of the database token
			Description DatabaseTokenDescription `json:"description"`
			Id          UuidV4                   `json:"id"`

			// Permissions The list of permissions the [database token](/influxdb3/cloud-dedicated/admin/tokens/database/) allows
			Permissions DatabaseTokenPermissions `json:"permissions"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateDatabaseTokenResponse parses an HTTP response from a CreateDatabaseTokenWithResponse call
func ParseCreateDatabaseTokenResponse(rsp *http.Response) (*CreateDatabaseTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDatabaseTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AccessToken The access token that can be used to authenticate query and write requests to the cluster
			//
			// The access token is never stored by InfluxDB and is only returned once when the token is created. If the access token is lost, a new token must be created.
			AccessToken DatabaseTokenAccessToken `json:"accessToken"`
			AccountId   UuidV4                   `json:"accountId"`
			ClusterId   UuidV4                   `json:"clusterId"`
			CreatedAt   DatabaseTokenCreatedAt   `json:"createdAt"`

			// Description The description of the database token
			Description DatabaseTokenDescription `json:"description"`
			Id          UuidV4                   `json:"id"`

			// Permissions The list of permissions the [database token](/influxdb3/cloud-dedicated/admin/tokens/database/) allows
			Permissions DatabaseTokenPermissions `json:"permissions"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteDatabaseTokenResponse parses an HTTP response from a DeleteDatabaseTokenWithResponse call
func ParseDeleteDatabaseTokenResponse(rsp *http.Response) (*DeleteDatabaseTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDatabaseTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDatabaseTokenResponse parses an HTTP response from a GetDatabaseTokenWithResponse call
func ParseGetDatabaseTokenResponse(rsp *http.Response) (*GetDatabaseTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDatabaseTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AccountId UuidV4                 `json:"accountId"`
			ClusterId UuidV4                 `json:"clusterId"`
			CreatedAt DatabaseTokenCreatedAt `json:"createdAt"`

			// Description The description of the database token
			Description DatabaseTokenDescription `json:"description"`
			Id          UuidV4                   `json:"id"`

			// Permissions The list of permissions the [database token](/influxdb3/cloud-dedicated/admin/tokens/database/) allows
			Permissions DatabaseTokenPermissions `json:"permissions"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateDatabaseTokenResponse parses an HTTP response from a UpdateDatabaseTokenWithResponse call
func ParseUpdateDatabaseTokenResponse(rsp *http.Response) (*UpdateDatabaseTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDatabaseTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AccountId UuidV4                 `json:"accountId"`
			ClusterId UuidV4                 `json:"clusterId"`
			CreatedAt DatabaseTokenCreatedAt `json:"createdAt"`

			// Description The description of the database token
			Description DatabaseTokenDescription `json:"description"`
			Id          UuidV4                   `json:"id"`

			// Permissions The list of permissions the [database token](/influxdb3/cloud-dedicated/admin/tokens/database/) allows
			Permissions DatabaseTokenPermissions `json:"permissions"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}
