// Package cloud provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package cloud

import (
	"encoding/json"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthJwtScopes             = "bearerAuthJwt.Scopes"
	BearerAuthManagementTokenScopes = "bearerAuthManagementToken.Scopes"
)

// Defines values for ClusterDatabasePartitionTemplatePartBucketType.
const (
	Bucket ClusterDatabasePartitionTemplatePartBucketType = "bucket"
)

// Defines values for ClusterDatabasePartitionTemplatePartTagValueType.
const (
	Tag ClusterDatabasePartitionTemplatePartTagValueType = "tag"
)

// Defines values for ClusterDatabasePartitionTemplatePartTimeFormatType.
const (
	Time ClusterDatabasePartitionTemplatePartTimeFormatType = "time"
)

// Defines values for DatabaseTokenResourceAllDatabases.
const (
	Asterisk DatabaseTokenResourceAllDatabases = "*"
)

// ClusterDatabaseMaxColumnsPerTable The maximum number of columns per table for the cluster database
type ClusterDatabaseMaxColumnsPerTable = int32

// ClusterDatabaseMaxTables The maximum number of tables for the cluster database
type ClusterDatabaseMaxTables = int32

// ClusterDatabaseName The name of the cluster database
type ClusterDatabaseName = string

// ClusterDatabasePartitionTemplate A template for [partitioning](/influxdb3/cloud-dedicated/admin/custom-partitions/) a cluster database.
//
// Each partition template part is evaluated in sequence.
// The outputs from each part are concatenated with the
// `|` delimiter to form the final partition key.
//
// For example, using the partition template below:
//
// ```json
// [
//
//	{
//	  "type": "time",
//	  "value": "%Y"
//	},
//	{
//	  "type": "tag",
//	  "value": "bananas"
//	},
//	{
//	  "type": "tag",
//	  "value": "plátanos"
//	},
//	{
//	  "type": "bucket",
//	  "value": {
//	    "tagName": "c",
//	    "numberOfBuckets": 10
//	  }
//	}
//
// ]
// ```
//
// The following partition keys are derived:
//
//   - `time=2023-01-01, a=bananas, b=plátanos, c=ananas`   -> `2023|bananas|plátanos|5`
//   - `time=2023-01-01, b=plátanos`                        -> `2023|!|plátanos|!`
//   - `time=2023-01-01, another=cat, b=plátanos`           -> `2023|!|plátanos|!`
//   - `time=2023-01-01`                                    -> `2023|!|!|!`
//   - `time=2023-01-01, a=cat|dog, b=!, c=!`               -> `2023|cat%7Cdog|%21|8`
//   - `time=2023-01-01, a=%50, c=%50`                      -> `2023|%2550|!|9`
//   - `time=2023-01-01, a=, c=`                            -> `2023|^|!|0`
//   - `time=2023-01-01, a=<long string>`                   -> `2023|<long string>#|!|!`
//   - `time=2023-01-01, c=<long string>`                   -> `2023|!|!|<bucket ID for untruncated long string>`
//
// When using the default [partitioning](/influxdb3/cloud-dedicated/admin/custom-partitions/) template (YYYY-MM-DD) there is no
// encoding necessary, as the derived partition key contains a single part, and
// no reserved characters. [`TemplatePart::Bucket`] parts by definition will
// always be within the part length limit and contain no restricted characters
// so are also not percent-encoded and/or truncated.
type ClusterDatabasePartitionTemplate = []ClusterDatabasePartitionTemplatePart

// ClusterDatabasePartitionTemplatePart A sub-part of a `PartitionTemplate`
type ClusterDatabasePartitionTemplatePart struct {
	union json.RawMessage
}

// ClusterDatabasePartitionTemplatePartBucket A bucketing matcher that sorts data through a uniform hash function on the values of the given tag name.
//
// If a row does not contain a value for the specified tag name, the NULL/missing partition key part `!` is rendered.
type ClusterDatabasePartitionTemplatePartBucket struct {
	Type  *ClusterDatabasePartitionTemplatePartBucketType `json:"type,omitempty"`
	Value *struct {
		// NumberOfBuckets The number of buckets tag values are distributed across
		NumberOfBuckets *int32 `json:"numberOfBuckets,omitempty"`

		// TagName The name of the tag used to derive the bucket the data belongs in
		TagName *string `json:"tagName,omitempty"`
	} `json:"value,omitempty"`
}

// ClusterDatabasePartitionTemplatePartBucketType defines model for ClusterDatabasePartitionTemplatePartBucket.Type.
type ClusterDatabasePartitionTemplatePartBucketType string

// ClusterDatabasePartitionTemplatePartTagValue A tag value matcher that extracts a string value from the specified tag name
//
// If a row does not contain a value for the specified tag name, the NULL/missing partition key part `!` is rendered.
type ClusterDatabasePartitionTemplatePartTagValue struct {
	Type  *ClusterDatabasePartitionTemplatePartTagValueType `json:"type,omitempty"`
	Value *string                                           `json:"value,omitempty"`
}

// ClusterDatabasePartitionTemplatePartTagValueType defines model for ClusterDatabasePartitionTemplatePartTagValue.Type.
type ClusterDatabasePartitionTemplatePartTagValueType string

// ClusterDatabasePartitionTemplatePartTimeFormat A time format matcher that accepts a "strftime"-like format string and evaluates it against the "time" column
type ClusterDatabasePartitionTemplatePartTimeFormat struct {
	Type  *ClusterDatabasePartitionTemplatePartTimeFormatType `json:"type,omitempty"`
	Value *string                                             `json:"value,omitempty"`
}

// ClusterDatabasePartitionTemplatePartTimeFormatType defines model for ClusterDatabasePartitionTemplatePartTimeFormat.Type.
type ClusterDatabasePartitionTemplatePartTimeFormatType string

// ClusterDatabaseRetentionPeriod The retention period of the [cluster database](/influxdb3/cloud-dedicated/admin/databases/) in nanoseconds, if applicable
//
// If the retention period is not set or is set to 0, the database will have infinite retention
type ClusterDatabaseRetentionPeriod = int64

// ClusterDatabaseTableName The name of the [cluster database](/influxdb3/cloud-dedicated/admin/databases/) table
type ClusterDatabaseTableName = string

// DatabaseTokenAccessToken The access token that can be used to authenticate query and write requests to the cluster
//
// The access token is never stored by InfluxDB and is only returned once when the token is created. If the access token is lost, a new token must be created.
type DatabaseTokenAccessToken = string

// DatabaseTokenCreatedAt defines model for DatabaseTokenCreatedAt.
type DatabaseTokenCreatedAt = DateTimeRfc3339

// DatabaseTokenDescription The description of the database token
type DatabaseTokenDescription = string

// DatabaseTokenPermission The description of the database token
type DatabaseTokenPermission struct {
	// Action The action the [database token](/influxdb3/cloud-dedicated/admin/tokens/database/) permission allows
	Action *DatabaseTokenPermissionAction `json:"action,omitempty"`

	// Resource The resource the [database token](/influxdb3/cloud-dedicated/admin/tokens/database/) permission applies to
	Resource *DatabaseTokenPermissionResource `json:"resource,omitempty"`
}

// DatabaseTokenPermissionAction The action the [database token](/influxdb3/cloud-dedicated/admin/tokens/database/) permission allows
type DatabaseTokenPermissionAction = string

// DatabaseTokenPermissionResource The resource the [database token](/influxdb3/cloud-dedicated/admin/tokens/database/) permission applies to
type DatabaseTokenPermissionResource struct {
	union json.RawMessage
}

// DatabaseTokenPermissions The list of permissions the [database token](/influxdb3/cloud-dedicated/admin/tokens/database/) allows
type DatabaseTokenPermissions = []DatabaseTokenPermission

// DatabaseTokenResourceAllDatabases A resource value for a [database token](/influxdb3/cloud-dedicated/admin/tokens/database/) permission that refers to all databases
type DatabaseTokenResourceAllDatabases string

// DateTimeRfc3339 defines model for DateTimeRfc3339.
type DateTimeRfc3339 = time.Time

// Error defines model for Error.
type Error struct {
	Code    int    `json:"code"`
	Message string `json:"message"`
}

// UuidV4 defines model for UuidV4.
type UuidV4 = openapi_types.UUID

// BadRequest defines model for BadRequest.
type BadRequest = Error

// Conflict defines model for Conflict.
type Conflict = Error

// Forbidden defines model for Forbidden.
type Forbidden = Error

// InternalServerError defines model for InternalServerError.
type InternalServerError = Error

// NotFound defines model for NotFound.
type NotFound = Error

// Unauthorized defines model for Unauthorized.
type Unauthorized = Error

// CreateClusterDatabaseJSONBody defines parameters for CreateClusterDatabase.
type CreateClusterDatabaseJSONBody struct {
	// MaxColumnsPerTable The maximum number of columns per table for the cluster database
	MaxColumnsPerTable *ClusterDatabaseMaxColumnsPerTable `json:"maxColumnsPerTable,omitempty"`

	// MaxTables The maximum number of tables for the cluster database
	MaxTables *ClusterDatabaseMaxTables `json:"maxTables,omitempty"`

	// Name The name of the cluster database
	Name ClusterDatabaseName `json:"name"`

	// PartitionTemplate A template for [partitioning](/influxdb3/cloud-dedicated/admin/custom-partitions/) a cluster database.
	//
	// Each partition template part is evaluated in sequence.
	// The outputs from each part are concatenated with the
	// `|` delimiter to form the final partition key.
	//
	// For example, using the partition template below:
	//
	// ```json
	// [
	//   {
	//     "type": "time",
	//     "value": "%Y"
	//   },
	//   {
	//     "type": "tag",
	//     "value": "bananas"
	//   },
	//   {
	//     "type": "tag",
	//     "value": "plátanos"
	//   },
	//   {
	//     "type": "bucket",
	//     "value": {
	//       "tagName": "c",
	//       "numberOfBuckets": 10
	//     }
	//   }
	// ]
	// ```
	//
	// The following partition keys are derived:
	//
	//   * `time=2023-01-01, a=bananas, b=plátanos, c=ananas`   -> `2023|bananas|plátanos|5`
	//   * `time=2023-01-01, b=plátanos`                        -> `2023|!|plátanos|!`
	//   * `time=2023-01-01, another=cat, b=plátanos`           -> `2023|!|plátanos|!`
	//   * `time=2023-01-01`                                    -> `2023|!|!|!`
	//   * `time=2023-01-01, a=cat|dog, b=!, c=!`               -> `2023|cat%7Cdog|%21|8`
	//   * `time=2023-01-01, a=%50, c=%50`                      -> `2023|%2550|!|9`
	//   * `time=2023-01-01, a=, c=`                            -> `2023|^|!|0`
	//   * `time=2023-01-01, a=<long string>`                   -> `2023|<long string>#|!|!`
	//   * `time=2023-01-01, c=<long string>`                   -> `2023|!|!|<bucket ID for untruncated long string>`
	//
	// When using the default [partitioning](/influxdb3/cloud-dedicated/admin/custom-partitions/) template (YYYY-MM-DD) there is no
	// encoding necessary, as the derived partition key contains a single part, and
	// no reserved characters. [`TemplatePart::Bucket`] parts by definition will
	// always be within the part length limit and contain no restricted characters
	// so are also not percent-encoded and/or truncated.
	PartitionTemplate *ClusterDatabasePartitionTemplate `json:"partitionTemplate,omitempty"`

	// RetentionPeriod The retention period of the [cluster database](/influxdb3/cloud-dedicated/admin/databases/) in nanoseconds, if applicable
	//
	// If the retention period is not set or is set to 0, the database will have infinite retention
	RetentionPeriod *ClusterDatabaseRetentionPeriod `json:"retentionPeriod,omitempty"`
}

// UpdateClusterDatabaseJSONBody defines parameters for UpdateClusterDatabase.
type UpdateClusterDatabaseJSONBody struct {
	// MaxColumnsPerTable The maximum number of columns per table for the cluster database
	MaxColumnsPerTable *ClusterDatabaseMaxColumnsPerTable `json:"maxColumnsPerTable,omitempty"`

	// MaxTables The maximum number of tables for the cluster database
	MaxTables *ClusterDatabaseMaxTables `json:"maxTables,omitempty"`

	// RetentionPeriod The retention period of the [cluster database](/influxdb3/cloud-dedicated/admin/databases/) in nanoseconds, if applicable
	//
	// If the retention period is not set or is set to 0, the database will have infinite retention
	RetentionPeriod *ClusterDatabaseRetentionPeriod `json:"retentionPeriod,omitempty"`
}

// CreateClusterDatabaseTableJSONBody defines parameters for CreateClusterDatabaseTable.
type CreateClusterDatabaseTableJSONBody struct {
	// Name The name of the [cluster database](/influxdb3/cloud-dedicated/admin/databases/) table
	Name ClusterDatabaseTableName `json:"name"`

	// PartitionTemplate A template for [partitioning](/influxdb3/cloud-dedicated/admin/custom-partitions/) a cluster database.
	//
	// Each partition template part is evaluated in sequence.
	// The outputs from each part are concatenated with the
	// `|` delimiter to form the final partition key.
	//
	// For example, using the partition template below:
	//
	// ```json
	// [
	//   {
	//     "type": "time",
	//     "value": "%Y"
	//   },
	//   {
	//     "type": "tag",
	//     "value": "bananas"
	//   },
	//   {
	//     "type": "tag",
	//     "value": "plátanos"
	//   },
	//   {
	//     "type": "bucket",
	//     "value": {
	//       "tagName": "c",
	//       "numberOfBuckets": 10
	//     }
	//   }
	// ]
	// ```
	//
	// The following partition keys are derived:
	//
	//   * `time=2023-01-01, a=bananas, b=plátanos, c=ananas`   -> `2023|bananas|plátanos|5`
	//   * `time=2023-01-01, b=plátanos`                        -> `2023|!|plátanos|!`
	//   * `time=2023-01-01, another=cat, b=plátanos`           -> `2023|!|plátanos|!`
	//   * `time=2023-01-01`                                    -> `2023|!|!|!`
	//   * `time=2023-01-01, a=cat|dog, b=!, c=!`               -> `2023|cat%7Cdog|%21|8`
	//   * `time=2023-01-01, a=%50, c=%50`                      -> `2023|%2550|!|9`
	//   * `time=2023-01-01, a=, c=`                            -> `2023|^|!|0`
	//   * `time=2023-01-01, a=<long string>`                   -> `2023|<long string>#|!|!`
	//   * `time=2023-01-01, c=<long string>`                   -> `2023|!|!|<bucket ID for untruncated long string>`
	//
	// When using the default [partitioning](/influxdb3/cloud-dedicated/admin/custom-partitions/) template (YYYY-MM-DD) there is no
	// encoding necessary, as the derived partition key contains a single part, and
	// no reserved characters. [`TemplatePart::Bucket`] parts by definition will
	// always be within the part length limit and contain no restricted characters
	// so are also not percent-encoded and/or truncated.
	PartitionTemplate *ClusterDatabasePartitionTemplate `json:"partitionTemplate,omitempty"`
}

// CreateDatabaseTokenJSONBody defines parameters for CreateDatabaseToken.
type CreateDatabaseTokenJSONBody struct {
	// Description The description of the database token
	Description DatabaseTokenDescription `json:"description"`

	// Permissions The list of permissions the [database token](/influxdb3/cloud-dedicated/admin/tokens/database/) allows
	Permissions *DatabaseTokenPermissions `json:"permissions,omitempty"`
}

// UpdateDatabaseTokenJSONBody defines parameters for UpdateDatabaseToken.
type UpdateDatabaseTokenJSONBody struct {
	// Description The description of the database token
	Description *DatabaseTokenDescription `json:"description,omitempty"`

	// Permissions The list of permissions the [database token](/influxdb3/cloud-dedicated/admin/tokens/database/) allows
	Permissions *DatabaseTokenPermissions `json:"permissions,omitempty"`
}

// CreateClusterDatabaseJSONRequestBody defines body for CreateClusterDatabase for application/json ContentType.
type CreateClusterDatabaseJSONRequestBody CreateClusterDatabaseJSONBody

// UpdateClusterDatabaseJSONRequestBody defines body for UpdateClusterDatabase for application/json ContentType.
type UpdateClusterDatabaseJSONRequestBody UpdateClusterDatabaseJSONBody

// CreateClusterDatabaseTableJSONRequestBody defines body for CreateClusterDatabaseTable for application/json ContentType.
type CreateClusterDatabaseTableJSONRequestBody CreateClusterDatabaseTableJSONBody

// CreateDatabaseTokenJSONRequestBody defines body for CreateDatabaseToken for application/json ContentType.
type CreateDatabaseTokenJSONRequestBody CreateDatabaseTokenJSONBody

// UpdateDatabaseTokenJSONRequestBody defines body for UpdateDatabaseToken for application/json ContentType.
type UpdateDatabaseTokenJSONRequestBody UpdateDatabaseTokenJSONBody

// AsClusterDatabasePartitionTemplatePartTagValue returns the union data inside the ClusterDatabasePartitionTemplatePart as a ClusterDatabasePartitionTemplatePartTagValue
func (t ClusterDatabasePartitionTemplatePart) AsClusterDatabasePartitionTemplatePartTagValue() (ClusterDatabasePartitionTemplatePartTagValue, error) {
	var body ClusterDatabasePartitionTemplatePartTagValue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromClusterDatabasePartitionTemplatePartTagValue overwrites any union data inside the ClusterDatabasePartitionTemplatePart as the provided ClusterDatabasePartitionTemplatePartTagValue
func (t *ClusterDatabasePartitionTemplatePart) FromClusterDatabasePartitionTemplatePartTagValue(v ClusterDatabasePartitionTemplatePartTagValue) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeClusterDatabasePartitionTemplatePartTagValue performs a merge with any union data inside the ClusterDatabasePartitionTemplatePart, using the provided ClusterDatabasePartitionTemplatePartTagValue
func (t *ClusterDatabasePartitionTemplatePart) MergeClusterDatabasePartitionTemplatePartTagValue(v ClusterDatabasePartitionTemplatePartTagValue) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsClusterDatabasePartitionTemplatePartTimeFormat returns the union data inside the ClusterDatabasePartitionTemplatePart as a ClusterDatabasePartitionTemplatePartTimeFormat
func (t ClusterDatabasePartitionTemplatePart) AsClusterDatabasePartitionTemplatePartTimeFormat() (ClusterDatabasePartitionTemplatePartTimeFormat, error) {
	var body ClusterDatabasePartitionTemplatePartTimeFormat
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromClusterDatabasePartitionTemplatePartTimeFormat overwrites any union data inside the ClusterDatabasePartitionTemplatePart as the provided ClusterDatabasePartitionTemplatePartTimeFormat
func (t *ClusterDatabasePartitionTemplatePart) FromClusterDatabasePartitionTemplatePartTimeFormat(v ClusterDatabasePartitionTemplatePartTimeFormat) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeClusterDatabasePartitionTemplatePartTimeFormat performs a merge with any union data inside the ClusterDatabasePartitionTemplatePart, using the provided ClusterDatabasePartitionTemplatePartTimeFormat
func (t *ClusterDatabasePartitionTemplatePart) MergeClusterDatabasePartitionTemplatePartTimeFormat(v ClusterDatabasePartitionTemplatePartTimeFormat) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsClusterDatabasePartitionTemplatePartBucket returns the union data inside the ClusterDatabasePartitionTemplatePart as a ClusterDatabasePartitionTemplatePartBucket
func (t ClusterDatabasePartitionTemplatePart) AsClusterDatabasePartitionTemplatePartBucket() (ClusterDatabasePartitionTemplatePartBucket, error) {
	var body ClusterDatabasePartitionTemplatePartBucket
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromClusterDatabasePartitionTemplatePartBucket overwrites any union data inside the ClusterDatabasePartitionTemplatePart as the provided ClusterDatabasePartitionTemplatePartBucket
func (t *ClusterDatabasePartitionTemplatePart) FromClusterDatabasePartitionTemplatePartBucket(v ClusterDatabasePartitionTemplatePartBucket) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeClusterDatabasePartitionTemplatePartBucket performs a merge with any union data inside the ClusterDatabasePartitionTemplatePart, using the provided ClusterDatabasePartitionTemplatePartBucket
func (t *ClusterDatabasePartitionTemplatePart) MergeClusterDatabasePartitionTemplatePartBucket(v ClusterDatabasePartitionTemplatePartBucket) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ClusterDatabasePartitionTemplatePart) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ClusterDatabasePartitionTemplatePart) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsClusterDatabaseName returns the union data inside the DatabaseTokenPermissionResource as a ClusterDatabaseName
func (t DatabaseTokenPermissionResource) AsClusterDatabaseName() (ClusterDatabaseName, error) {
	var body ClusterDatabaseName
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromClusterDatabaseName overwrites any union data inside the DatabaseTokenPermissionResource as the provided ClusterDatabaseName
func (t *DatabaseTokenPermissionResource) FromClusterDatabaseName(v ClusterDatabaseName) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeClusterDatabaseName performs a merge with any union data inside the DatabaseTokenPermissionResource, using the provided ClusterDatabaseName
func (t *DatabaseTokenPermissionResource) MergeClusterDatabaseName(v ClusterDatabaseName) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDatabaseTokenResourceAllDatabases returns the union data inside the DatabaseTokenPermissionResource as a DatabaseTokenResourceAllDatabases
func (t DatabaseTokenPermissionResource) AsDatabaseTokenResourceAllDatabases() (DatabaseTokenResourceAllDatabases, error) {
	var body DatabaseTokenResourceAllDatabases
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDatabaseTokenResourceAllDatabases overwrites any union data inside the DatabaseTokenPermissionResource as the provided DatabaseTokenResourceAllDatabases
func (t *DatabaseTokenPermissionResource) FromDatabaseTokenResourceAllDatabases(v DatabaseTokenResourceAllDatabases) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDatabaseTokenResourceAllDatabases performs a merge with any union data inside the DatabaseTokenPermissionResource, using the provided DatabaseTokenResourceAllDatabases
func (t *DatabaseTokenPermissionResource) MergeDatabaseTokenResourceAllDatabases(v DatabaseTokenResourceAllDatabases) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DatabaseTokenPermissionResource) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DatabaseTokenPermissionResource) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}
